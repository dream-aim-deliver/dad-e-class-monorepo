'use client';

// Auto-generated by page-scaffold command
// TSK: TSK-1
// Features: listTopics, getProfessionalProfile, saveProfessionalProfile
// Route: /workspace/profile

import { viewModels, fileMetadata } from '@maany_shr/e-class-models';
import { USERNAME_REGEX } from '@dream-aim-deliver/e-class-cms-rest';
import { trpc } from '../trpc/cms-client';
import { z } from 'zod';
import { useState, useEffect, useMemo } from 'react';
import {
	DefaultLoading,
	DefaultError,
	ProfileTabs,
	Breadcrumbs,
	Dialog,
	DialogContent,
	DialogBody,
	ProfessionalInfo
} from '@maany_shr/e-class-ui-kit';
import { useLocale, useTranslations } from 'next-intl';
import { TLocale } from '@maany_shr/e-class-translations';
import { useSession } from 'next-auth/react';
import { useRouter, useSearchParams } from 'next/navigation';
import { useGetProfessionalProfilePresenter } from '../hooks/use-get-professional-profile-presenter';
import { useGetPersonalProfilePresenter } from '../hooks/use-get-personal-profile-presenter';
import { useListTopicsPresenter } from '../hooks/use-topics-presenter';
import { useListLanguagesPresenter } from '../hooks/use-list-languages-presenter';
import { useProfilePictureUpload } from './workspace/edit/hooks/use-profile-picture-upload';
import { useCurriculumVitaeUpload } from './workspace/edit/hooks/use-curriculum-vitae-upload';
import Banner from 'packages/ui-kit/lib/components/banner';
import { usePlatform } from '../context/platform-context';

interface ProfileProps {
	locale: string;
	userEmail: string;
	username: string;
	roles: string[];
}

// LinkedIn URL validation regex - matches standard LinkedIn profile/company URLs
const linkedInUrlRegex = /^https:\/\/(www\.)?linkedin\.com\/(in|company|school|showcase)\/[\w-]+\/?$/;

// Zod schema for professional profile validation
const professionalProfileValidationSchema = z.object({
	bio: z.string().min(1, 'Bio is required').max(280, 'Bio must be 280 characters or less'),
	linkedinUrl: z.union([
		z.string().refine(
			(url) => url === '' || linkedInUrlRegex.test(url),
			{ message: 'Please enter a valid LinkedIn URL (e.g., https://linkedin.com/in/username)' }
		),
		z.null(),
		z.undefined()
	]).optional(),
	portfolioWebsite: z.union([
		z.string().refine(
			(url) => {
				if (!url || url === '') return true;
				try {
					new URL(url);
					return true;
				} catch {
					return false;
				}
			},
			{ message: 'Please enter a valid portfolio website URL' }
		),
		z.null(),
		z.undefined()
	]).optional(),
});

export default function Profile({ locale: localeStr, userEmail, username, roles }: ProfileProps) {
	const locale = useLocale() as TLocale;
	const router = useRouter();
	const searchParams = useSearchParams();
	const t = useTranslations('pages.profile');
	const breadcrumbsTranslations = useTranslations('components.breadcrumbs');
	const professionalInfoTranslations = useTranslations('components.professionalInfo');
	const { update: updateSession } = useSession();
	const utils = trpc.useUtils();
	const platformContext = usePlatform();
	const supportEmail = platformContext?.platform.supportEmailAddress;

	// Upload progress state - separate for each upload type
	const [profilePictureUploadProgress, setProfilePictureUploadProgress] = useState<number>(0);
	const [curriculumVitaeUploadProgress, setCurriculumVitaeUploadProgress] = useState<number>(0);

	// State for messages
	const [errorMessage, setErrorMessage] = useState<string | null>(null);
	const [successMessage, setSuccessMessage] = useState<string | null>(null);

	// State for application modal
	const [isApplicationModalOpen, setIsApplicationModalOpen] = useState(false);
	const [applicationFormData, setApplicationFormData] = useState<viewModels.TGetProfessionalProfileSuccess['profile'] | null>(null);
	// Separate message state for application modal
	const [applicationModalErrorMessage, setApplicationModalErrorMessage] = useState<string | null>(null);
	const [applicationModalSuccessMessage, setApplicationModalSuccessMessage] = useState<string | null>(null);
	// Track if application is being processed (includes pending state and closing delay)
	const [isApplicationProcessing, setIsApplicationProcessing] = useState(false);

	// Separate CV upload hook for application modal (to avoid conflicts)
	const [applicationModalCvUploadProgress, setApplicationModalCvUploadProgress] = useState<number>(0);
	const applicationModalCurriculumVitaeUpload = useCurriculumVitaeUpload({
		initialDocument: null,
		onProgressUpdate: setApplicationModalCvUploadProgress,
	});


	// Always fetch personal profile data and languages (needed for default tab)
	const [personalProfileResponse] = trpc.getPersonalProfile.useSuspenseQuery({});
	const [languagesResponse] = trpc.listLanguages.useSuspenseQuery({ queryType: "all" });

	// Lazy fetch professional profile data and topics only when needed
	const professionalProfileQuery = trpc.getProfessionalProfile.useQuery({}, {
		refetchOnWindowFocus: false,
		staleTime: 5 * 60 * 1000,
	});
	// Topics are locale-dependent - force refetch on mount to get correct language
	// (React Query cache key doesn't include locale from Accept-Language header)
	const topicsQuery = trpc.listTopics.useQuery({}, {
		refetchOnWindowFocus: false,
		staleTime: 0,
		refetchOnMount: 'always',
	});


	const [professionalProfileViewModel, setProfessionalProfileViewModel] = useState<
		viewModels.TGetProfessionalProfileViewModel | undefined
	>(undefined);
	const [personalProfileViewModel, setPersonalProfileViewModel] = useState<
		viewModels.TGetPersonalProfileViewModel | undefined
	>(undefined);
	const [topicsViewModel, setTopicsViewModel] = useState<
		viewModels.TTopicListViewModel | undefined
	>(undefined);
	const [languagesViewModel, setLanguagesViewModel] = useState<
		viewModels.TLanguageListViewModel | undefined
	>(undefined);

	// Initialize presenters
	const { presenter: professionalPresenter } = useGetProfessionalProfilePresenter(
		setProfessionalProfileViewModel
	);
	const { presenter: personalPresenter } = useGetPersonalProfilePresenter(
		setPersonalProfileViewModel
	);
	const { presenter: topicsPresenter } = useListTopicsPresenter(
		setTopicsViewModel
	);
	const { presenter: languagesPresenter } = useListLanguagesPresenter(
		setLanguagesViewModel
	);

	const handleTabChange = (newTab: string) => {
		const tabValue = newTab as 'personal' | 'professional';
		const currentParams = new URLSearchParams(searchParams.toString());
		currentParams.set('tab', tabValue);
		router.push(`?${currentParams.toString()}`);
		return true;
	};

	// Present data to view models - always present personal and languages
	useEffect(() => {
		// @ts-ignore - Presenter type compatibility issue
		personalPresenter.present(personalProfileResponse, personalProfileViewModel);
		// @ts-ignore - Presenter type compatibility issue
		languagesPresenter.present(languagesResponse, languagesViewModel);
	}, [personalProfileResponse, languagesResponse, personalPresenter, languagesPresenter, personalProfileViewModel, languagesViewModel]);

	// Present professional data only when available
	useEffect(() => {
		if (professionalProfileQuery.data) {
			// @ts-ignore - Presenter type compatibility issue
			professionalPresenter.present(professionalProfileQuery.data, professionalProfileViewModel);
		}
	}, [professionalProfileQuery.data, professionalPresenter, professionalProfileViewModel]);

	// Present topics data only when available
	useEffect(() => {
		if (topicsQuery.data) {
			// @ts-ignore - Presenter type compatibility issue
			topicsPresenter.present(topicsQuery.data, topicsViewModel);
		}
	}, [topicsQuery.data, topicsPresenter, topicsViewModel]);



	// Extract profile data from view models - do this BEFORE any early returns
	// to ensure hooks always receive consistent data
	const personalProfile = personalProfileViewModel?.mode === 'default' ? personalProfileViewModel.data.profile : null;
	const professionalProfile = professionalProfileViewModel?.mode === 'default' ? professionalProfileViewModel.data.profile : null;

	// Memoize file metadata objects to prevent unnecessary re-creation
	const initialProfilePicture = useMemo((): fileMetadata.TFileMetadataImage | null => {
		return personalProfile?.avatarImage ? {
			id: personalProfile.avatarImage.id,
			name: personalProfile.avatarImage.name,
			url: personalProfile.avatarImage.downloadUrl,
			thumbnailUrl: personalProfile.avatarImage.downloadUrl,
			size: personalProfile.avatarImage.size,
			category: 'image' as const,
			status: 'available' as const,
		} : null;
	}, [personalProfile?.avatarImage]);

	// Transform curriculumVitae to TFileMetadata (document type) if it exists
	type TFileMetadataDocument = Extract<fileMetadata.TFileMetadata, { category: 'document' }>;
	const initialCurriculumVitae = useMemo((): TFileMetadataDocument | null => {
		return professionalProfile?.curriculumVitae ? {
			id: professionalProfile.curriculumVitae.id,
			name: professionalProfile.curriculumVitae.name,
			url: professionalProfile.curriculumVitae.downloadUrl,
			size: professionalProfile.curriculumVitae.size,
			category: 'document' as const,
			status: 'available' as const,
		} : null;
	}, [professionalProfile?.curriculumVitae]);

	// Save mutations with error handling (must be called unconditionally)
	const savePersonalMutation = trpc.savePersonalProfile.useMutation({
		onMutate: () => {
			setErrorMessage(null);
			setSuccessMessage(null);
		},
		onSuccess: async (data) => {
			setSuccessMessage(t('personalProfileSaved'));
			setErrorMessage(null);
			await utils.getPersonalProfile.invalidate();
			// Pass new avatar URL directly to session update (bypasses expired token issues)
			const responseData = data as any;
			const newAvatarUrl = responseData?.data?.profile?.avatarImage?.downloadUrl || null;
			await updateSession({ image: newAvatarUrl });
			router.refresh();
		},
		onError: (error) => {
			setErrorMessage(error.message || t('failedToSavePersonal'));
			setSuccessMessage(null);
		}
	});

	const saveProfessionalMutation = trpc.saveProfessionalProfile.useMutation({
		onMutate: (variables) => {
			// Only clear messages for the relevant context based on whether this is an application
			const isApplication = (variables as any)?.applyToBecomeCoach === true;
			if (isApplication) {
				// Clear only application modal messages
				setApplicationModalErrorMessage(null);
				setApplicationModalSuccessMessage(null);
				setIsApplicationProcessing(true); // Start processing state
			} else {
				// Clear only main page messages
				setErrorMessage(null);
				setSuccessMessage(null);
			}
		},
		onSuccess: async (data, variables) => {
			// Check if this was an application submission by checking if applyToBecomeCoach flag is present
			const isApplication = (variables as any)?.applyToBecomeCoach === true;

			if (isApplication) {

				// Check if the response actually indicates an error (some backends return 200 with error in body)
				// Handle case where tRPC returns error in onSuccess with { success: false, data: {...} }
				if (data && typeof data === 'object') {
					const dataObj = data as any;

					// Check for error in data.data.message (CAPS framework structure)
					if (dataObj.data?.message === 'COACH_APPLICATION_RATE_LIMIT') {
						setApplicationModalErrorMessage(t('applicationRateLimitExceeded'));
						setApplicationModalSuccessMessage(null);
						setIsApplicationProcessing(false);
						return;
					}

					// Check for success: false pattern
					if ('success' in dataObj && dataObj.success === false) {
						const errorData = dataObj.data;
						if (errorData?.message === 'COACH_APPLICATION_RATE_LIMIT') {
							setApplicationModalErrorMessage(t('applicationRateLimitExceeded'));
							setApplicationModalSuccessMessage(null);
							setIsApplicationProcessing(false);
							return;
						}
					}
				}

				setApplicationModalSuccessMessage(t('applicationSubmittedSuccessfully'));
				setApplicationModalErrorMessage(null);
				// Invalidate and refetch the professional profile to sync with server state
				await utils.getProfessionalProfile.invalidate();

				// Close modal after delay - keep buttons disabled during this time
				setTimeout(() => {
					setIsApplicationModalOpen(false);
					setApplicationModalSuccessMessage(null);
					setApplicationModalErrorMessage(null);
					setIsApplicationProcessing(false); // End processing state
					// Reset CV upload state
					if (applicationModalCurriculumVitaeUpload.curriculumVitae) {
						applicationModalCurriculumVitaeUpload.handleDelete(applicationModalCurriculumVitaeUpload.curriculumVitae.id);
					}
				}, 3000);
			} else {
				setSuccessMessage(t('professionalProfileSaved'));
				setErrorMessage(null);
				// Invalidate and refetch the professional profile to sync with server state
				await utils.getProfessionalProfile.invalidate();
			}
		},
		onError: (error: any, variables) => {
			// Check if this was an application submission by checking if applyToBecomeCoach flag is present
			const isApplication = (variables as any)?.applyToBecomeCoach === true;

			if (isApplication) {

				// Use modal-specific error state
				// Check for coach application rate limit error (CAPS framework)
				// Check error.data.message first (as per actual backend response)
				if (
					error.data?.message === 'COACH_APPLICATION_RATE_LIMIT' ||
					error.data?.code === 'COACH_APPLICATION_RATE_LIMIT' ||
					error.message === 'COACH_APPLICATION_RATE_LIMIT'
				) {
					setApplicationModalErrorMessage(t('applicationRateLimitExceeded'));
					setApplicationModalSuccessMessage(null);
					setIsApplicationProcessing(false); // End processing state on error
				} else {
					setApplicationModalErrorMessage(error.message || t('failedToSaveProfessional'));
					setApplicationModalSuccessMessage(null);
					setIsApplicationProcessing(false); // End processing state on error
				}
			} else {
				// Use main page error state
				setErrorMessage(error.message || t('failedToSaveProfessional'));
				setSuccessMessage(null);
			}
		}
	});

	// Upload hooks (must be called unconditionally before any returns)
	const profilePictureUpload = useProfilePictureUpload({
		initialImage: initialProfilePicture,
		onProgressUpdate: setProfilePictureUploadProgress,
	});

	const curriculumVitaeUpload = useCurriculumVitaeUpload({
		initialDocument: initialCurriculumVitae,
		onProgressUpdate: setCurriculumVitaeUploadProgress,
	});

	if (!personalProfileViewModel || !languagesViewModel) {
		return <DefaultLoading locale={locale} variant="minimal" />;
	}

	// Error handling - profile or languages data failed to load
	if (personalProfileViewModel.mode === 'kaboom' || languagesViewModel.mode === 'kaboom') {
		if (supportEmail && supportEmail.trim() !== '') {
			return (
				<DefaultError
					type="withSupportEmail"
					locale={locale}
					title={t('loadError.title')}
					description={t('loadError.description')}
					supportEmailAddress={supportEmail}
				/>
			);
		} else {
			return (
				<DefaultError
					type="simple"
					locale={locale}
					title={t('loadError.title')}
					description={t('loadError.description')}
				/>
			);
		}
	}

	// Languages are required for both tabs
	if (languagesViewModel.mode !== 'default') {
		return (
			<DefaultError
				type="simple"
				locale={locale}
				title={t('languagesLoadError.title')}
				description={t('languagesLoadError.description')}
			/>
		);
	}

	const allLanguages = languagesViewModel.data.languages;

	// Ensure we have languages
	if (!allLanguages || allLanguages.length === 0) {
		return (
			<DefaultError
				type="simple"
				locale={locale}
				title={t('languagesMissingError.title')}
				description={t('languagesMissingError.description')}
			/>
		);
	}

	// Save handlers - must be defined after early returns
	const handleSavePersonalProfile = async (profile: any) => {
		if (!profile) return;

		// Client-side validation
		const errors: string[] = [];

		if (!profile.name || profile.name.trim() === '') {
			errors.push(t('nameRequired') || 'Name is required');
		}

		if (!profile.surname || profile.surname.trim() === '') {
			errors.push(t('surnameRequired') || 'Surname is required');
		}

		if (!profile.username || profile.username.trim() === '') {
			errors.push(t('usernameRequired'));
		} else if (!USERNAME_REGEX.test(profile.username)) {
			errors.push(t('usernameInvalid'));
		}

		if (!profile.email || profile.email.trim() === '') {
			errors.push(t('emailRequired'));
		}

		if (errors.length > 0) {
			setErrorMessage(errors.join(', '));
			setSuccessMessage(null);
			throw new Error("Validation failed");
		}

		const savePayload = {
			...profile,
			languageIds: profile.languages.map((lang: any) => {
				return typeof lang.id === 'number' ? lang.id : parseInt(lang.id as string);
			}),
			interfaceLanguageId: typeof profile.interfaceLanguage.id === 'number'
				? profile.interfaceLanguage.id
				: parseInt(profile.interfaceLanguage.id as string),
			avatarImageId: profilePictureUpload.profilePicture?.id
				? (typeof profilePictureUpload.profilePicture.id === 'number'
					? profilePictureUpload.profilePicture.id
					: parseInt(profilePictureUpload.profilePicture.id as string))
				: undefined
		};

		try {
			await savePersonalMutation.mutateAsync(savePayload);
		} catch (error) {
			// Error is already handled by the mutation's onError callback
			console.error('Failed to save personal profile:', error);
		}
	};

	// Get topics data (may be undefined if professional tab hasn't been loaded yet)
	const allTopics = topicsViewModel?.mode === 'default' ? topicsViewModel.data.topics : [];

	// Create default profiles when they don't exist (for upsert functionality)
	const defaultPersonalProfile: viewModels.TGetPersonalProfileSuccess['profile'] = {
		id: 0,
		name: '',
		surname: '',
		username: username,
		email: userEmail,
		phone: null,
		dateOfBirth: null,
		companyDetails: {
			isRepresentingCompany: false as const,
		},
		avatarImage: null,
		languages: [],
		interfaceLanguage: allLanguages[0], // This could change and is expensive
		receiveNewsletter: false,
	};

	const defaultProfessionalProfile: viewModels.TGetProfessionalProfileSuccess['profile'] = {
		id: 0,
		bio: '',
		linkedinUrl: null,
		curriculumVitae: null,
		skills: [],
		private: true,
	};

	// Use actual profiles if they exist, otherwise use defaults
	const personalProfileToUse = personalProfile || defaultPersonalProfile;
	const professionalProfileToUse = professionalProfile || defaultProfessionalProfile;

	const isCoach = roles.includes('coach');
	const isStudent = roles.includes('student') && !roles.includes('coach');

	// Handler for opening application modal
	const handleOpenApplicationModal = () => {
		setApplicationModalErrorMessage(null);
		setApplicationModalSuccessMessage(null);
		// Use existing professional profile data if available, otherwise use defaults
		setApplicationFormData(professionalProfileToUse);
		setIsApplicationProcessing(false);

		// Set CV in the upload hook if professional profile has one
		if (professionalProfileToUse?.curriculumVitae) {
			const cvDocument: Extract<fileMetadata.TFileMetadata, { category: 'document' }> = {
				id: professionalProfileToUse.curriculumVitae.id,
				name: professionalProfileToUse.curriculumVitae.name,
				url: professionalProfileToUse.curriculumVitae.downloadUrl,
				size: professionalProfileToUse.curriculumVitae.size,
				category: 'document' as const,
				status: 'available' as const,
			};
			applicationModalCurriculumVitaeUpload.handleUploadComplete(cvDocument);
		} else {
			// Clear CV if no professional profile CV exists
			if (applicationModalCurriculumVitaeUpload.curriculumVitae) {
				applicationModalCurriculumVitaeUpload.handleDelete(applicationModalCurriculumVitaeUpload.curriculumVitae.id);
			}
		}

		setIsApplicationModalOpen(true);
	};

	// Handler for closing modal - reset state
	const handleCloseApplicationModal = (open: boolean) => {
		if (!open && !saveProfessionalMutation.isPending && !isApplicationProcessing) {
			setIsApplicationModalOpen(false);
			setApplicationModalErrorMessage(null);
			setApplicationModalSuccessMessage(null);
			setApplicationFormData(null);
			setIsApplicationProcessing(false);
			// Reset CV upload state
			if (applicationModalCurriculumVitaeUpload.curriculumVitae) {
				applicationModalCurriculumVitaeUpload.handleDelete(applicationModalCurriculumVitaeUpload.curriculumVitae.id);
			}
		}
	};

	// Handler for discarding changes in modal
	const handleDiscardApplicationModal = () => {
		// Prevent discarding while save is in progress or processing
		if (saveProfessionalMutation.isPending || isApplicationProcessing) {
			return;
		}
		setApplicationFormData(defaultProfessionalProfile);
		setApplicationModalErrorMessage(null);
		setApplicationModalSuccessMessage(null);
		// Reset CV upload state
		if (applicationModalCurriculumVitaeUpload.curriculumVitae) {
			applicationModalCurriculumVitaeUpload.handleDelete(applicationModalCurriculumVitaeUpload.curriculumVitae.id);
		}
	};

	const handleSaveProfessionalProfile = async (profile: typeof professionalProfile) => {
		if (!profile) return;

		const validationResult = professionalProfileValidationSchema.safeParse({
			bio: profile.bio,
			linkedinUrl: profile.linkedinUrl,
			portfolioWebsite: profile.portfolioWebsite,
		});

		if (!validationResult.success) {
			const errors = validationResult.error.errors.map(err => err.message);
			setErrorMessage(errors.join(', '));
			setSuccessMessage(null);
			return; // Return early, don't call mutation
		}

		const savePayload = {
			...profile,
			skillIds: profile.skills.map(skill => {
				return typeof skill.id === 'number' ? skill.id : parseInt(skill.id as string);
			}),
			curriculumVitaeId: curriculumVitaeUpload.curriculumVitae?.id
				? (typeof curriculumVitaeUpload.curriculumVitae.id === 'number'
					? curriculumVitaeUpload.curriculumVitae.id
					: parseInt(curriculumVitaeUpload.curriculumVitae.id as string))
				: undefined
		}

		await saveProfessionalMutation.mutateAsync(savePayload);
	}

	// Handler for application submission
	const handleApplicationSubmit = async (profile: typeof professionalProfile) => {
		if (!profile) return;

		// CV validation - return early if validation fails, don't call mutation
		if (!applicationModalCurriculumVitaeUpload.curriculumVitae) {
			setApplicationModalErrorMessage(t('cvRequiredForApplication'));
			setApplicationModalSuccessMessage(null);
			return;
		}

		const validationResult = professionalProfileValidationSchema.safeParse({
			bio: profile.bio,
			linkedinUrl: profile.linkedinUrl,
			portfolioWebsite: profile.portfolioWebsite,
		});

		if (!validationResult.success) {
			const errors = validationResult.error.errors.map(err => err.message);
			setApplicationModalErrorMessage(errors.join(', '));
			setApplicationModalSuccessMessage(null);
			return; // Return early, don't call mutation
		}

		const savePayload = {
			...profile,
			skillIds: profile.skills.map(skill => {
				return typeof skill.id === 'number' ? skill.id : parseInt(skill.id as string);
			}),
			curriculumVitaeId: applicationModalCurriculumVitaeUpload.curriculumVitae?.id
				? (typeof applicationModalCurriculumVitaeUpload.curriculumVitae.id === 'number'
					? applicationModalCurriculumVitaeUpload.curriculumVitae.id
					: parseInt(applicationModalCurriculumVitaeUpload.curriculumVitae.id as string))
				: undefined,
			applyToBecomeCoach: true as boolean // Flag for backend - explicitly typed as boolean
		};

		// Only call mutation if validation passes
		await saveProfessionalMutation.mutateAsync(savePayload);
	};


	return (
		<div className="min-h-screen text-base-white flex flex-col gap-6">
			<div className="flex flex-col space-y-6 p-6">
				<Breadcrumbs
					items={[
						{
							label: breadcrumbsTranslations('home'),
							onClick: () => {
								router.push(`/${locale}`);
							},
						},
						{
							label: breadcrumbsTranslations('workspace'),
							onClick: () => {
								router.push(`/${locale}/workspace`);
							},
						},
						{
							label: breadcrumbsTranslations('yourProfile'),
							onClick: () => {
								// Current page, no action needed
							},
						},
					]}
				/>

				<div className="flex flex-col space-y-5 mx-auto w-full">
					<h1>{t('yourProfile')}</h1>

					<ProfileTabs
						personalProfile={personalProfileToUse}
						professionalProfile={professionalProfileToUse}
						availableSkills={allTopics}
						availableLanguages={allLanguages}
						onSavePersonal={handleSavePersonalProfile}
						onSaveProfessional={handleSaveProfessionalProfile}
						onPersonalFileUpload={profilePictureUpload.handleFileChange}
						onProfessionalFileUpload={curriculumVitaeUpload.handleFileChange}
						locale={locale}
						profilePictureFile={profilePictureUpload.profilePicture}
						onProfilePictureUploadComplete={profilePictureUpload.handleUploadComplete}
						onProfilePictureDelete={profilePictureUpload.handleDelete}
						onProfilePictureDownload={profilePictureUpload.handleDownload}
						profilePictureUploadProgress={profilePictureUploadProgress}
						curriculumVitaeFile={curriculumVitaeUpload.curriculumVitae}
						onCurriculumVitaeUploadComplete={curriculumVitaeUpload.handleUploadComplete as (file: fileMetadata.TFileMetadata) => void}
						onCurriculumVitaeDelete={curriculumVitaeUpload.handleDelete}
						onCurriculumVitaeDownload={curriculumVitaeUpload.handleDownload}
						curriculumVitaeUploadProgress={curriculumVitaeUploadProgress}
						isSaving={savePersonalMutation.isPending || saveProfessionalMutation.isPending}
						hasProfessionalProfile={isCoach}
						onTabChange={handleTabChange}
						skillsLanguageHint={professionalInfoTranslations('skillsLanguageHint')}
						showApplyToCoachButton={isStudent}
						onApplyToCoachClick={handleOpenApplicationModal}
						usernameValidator={(username) => {
							if (!username || username.trim() === '') return null;
							if (!USERNAME_REGEX.test(username)) return t('usernameInvalid');
							return null;
						}}
					/>


					{/* Display error message */}
					{errorMessage && (
						<Banner style="error" description={errorMessage} />
					)}

					{/* Display success message */}
					{successMessage && !(savePersonalMutation.isPending || saveProfessionalMutation.isPending) && (
						<Banner style="success" description={successMessage} />
					)}

					{/* Display loading state */}
					{(savePersonalMutation.isPending || saveProfessionalMutation.isPending) && (
						<Banner style="success" description={t('saving')} />
					)}
				</div>
			</div>

			{/* Application Modal */}
			<Dialog open={isApplicationModalOpen} onOpenChange={handleCloseApplicationModal} defaultOpen={false}>
				<DialogContent
					showCloseButton
					closeOnOverlayClick={!saveProfessionalMutation.isPending && !isApplicationProcessing}
					closeOnEscape={!saveProfessionalMutation.isPending && !isApplicationProcessing}
					disableCloseButton={saveProfessionalMutation.isPending || isApplicationProcessing}
					className="max-w-2xl max-h-[90vh] overflow-y-auto"
				>
					<DialogBody>
						<div className="flex flex-col gap-4">
							<h2 className="text-2xl font-bold text-text-primary">
								{t('coachApplicationTitle')}
							</h2>
							<p className="text-text-secondary">
								{t('coachApplicationDescription')}
							</p>

							{/* Loading state banner */}
							{(saveProfessionalMutation.isPending || isApplicationProcessing) && (
								<Banner style="success" description={saveProfessionalMutation.isPending ? t('saving') : applicationModalSuccessMessage || t('saving')} />
							)}

							{/* Error message banner */}
							{applicationModalErrorMessage && !saveProfessionalMutation.isPending && !isApplicationProcessing && (
								<Banner style="error" description={applicationModalErrorMessage} />
							)}

							{/* Success message banner */}
							{applicationModalSuccessMessage && !saveProfessionalMutation.isPending && !isApplicationProcessing && (
								<Banner style="success" description={applicationModalSuccessMessage} />
							)}

							<ProfessionalInfo
								initialData={applicationFormData || defaultProfessionalProfile}
								onChange={setApplicationFormData}
								availableSkills={allTopics}
								onSave={handleApplicationSubmit}
								onDiscard={handleDiscardApplicationModal}
								onFileUpload={applicationModalCurriculumVitaeUpload.handleFileChange}
								curriculumVitaeFile={applicationModalCurriculumVitaeUpload.curriculumVitae}
								onUploadComplete={applicationModalCurriculumVitaeUpload.handleUploadComplete as (file: fileMetadata.TFileMetadata) => void}
								onFileDelete={applicationModalCurriculumVitaeUpload.handleDelete}
								onFileDownload={applicationModalCurriculumVitaeUpload.handleDownload}
								locale={locale}
								uploadProgress={applicationModalCvUploadProgress}
								applicationMode={true}
								requireCV={true}
								isSaving={saveProfessionalMutation.isPending || isApplicationProcessing}
								skillsLanguageHint={professionalInfoTranslations('skillsLanguageHint')}
								onValidationError={(error) => {
									if (error) {
										setApplicationModalErrorMessage(error);
										setApplicationModalSuccessMessage(null);
									} else {
										setApplicationModalErrorMessage(null);
									}
								}}
							/>
						</div>
					</DialogBody>
				</DialogContent>
			</Dialog>
		</div>
	);
}


