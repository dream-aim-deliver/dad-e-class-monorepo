'use client';

// Auto-generated by page-scaffold command v2 - Refactored
// Notion: https://www.notion.so/Received-payments-Orders-Payments-Coach-workspace-2925a7432d01807fb248fc457b865e8d
// Usecases from Notion: listUserOutgoingTransactions, generateInvoicePdf
// Features from Notion: View received payments from students, Generate/Download invoices
// User Types from Notion: Coach
// Figma: https://www.figma.com/design/8KEwRuOoD5IgxTtFAtLlyS/Just_Do_Ad-1.2?node-id=7709-235261

import { useLocale, useTranslations } from 'next-intl';
import { TLocale } from '@maany_shr/e-class-translations';
import { trpc } from '../trpc/cms-client';
import { ReceivedPaymentsCard, ReceivedPaymentsCardList, Button, ConfirmationModal, DefaultError, DefaultLoading } from '@maany_shr/e-class-ui-kit';
import { useState, useEffect } from 'react';
import { generateInvoicePdf } from '../utils/generate-invoice-pdf';
import { getLocaleCountryCode } from '../utils/locale-mapping';
import { useRequiredPlatform } from '../context/platform-context';
import { viewModels } from '@maany_shr/e-class-models';
import { useListUserOutgoingTransactionsPresenter } from '../hooks/use-list-user-outgoing-transactions-presenter';

interface ReceivedPaymentsTabProps {
  locale: TLocale;
}

export default function ReceivedPaymentsTab({ locale }: ReceivedPaymentsTabProps) {
  const t = useTranslations('pages.receivedPayments');
  const currentLocale = useLocale() as TLocale;
  const { platform } = useRequiredPlatform();

  // Pagination state - show 8 cards initially (2 rows on desktop with 4 cols)
  const [visibleCount, setVisibleCount] = useState(8);
  const ITEMS_PER_PAGE = 8;
  const [isGeneratingPdf, setIsGeneratingPdf] = useState<string | null>(null);

  // Error modal state
  const [errorModal, setErrorModal] = useState<{
    isOpen: boolean;
    title: string;
    message: string;
  }>({
    isOpen: false,
    title: '',
    message: '',
  });

  // Fetch personal profile for company details in invoice (coach details)
  const [personalProfileResponse] = trpc.getPersonalProfile.useSuspenseQuery({});

  // TRPC query for listUserOutgoingTransactions usecase
  const [transactionsResponse, { refetch: refetchTransactions }] = trpc.listUserOutgoingTransactions.useSuspenseQuery({});

  // View model state
  const [transactionsViewModel, setTransactionsViewModel] = useState<
    viewModels.TListUserOutgoingTransactionsViewModel | undefined
  >(undefined);

  // Presenter
  const { presenter: transactionsPresenter } = useListUserOutgoingTransactionsPresenter(
    setTransactionsViewModel,
  );

  // Present the data when response changes
  useEffect(() => {
    // @ts-ignore
    transactionsPresenter.present(transactionsResponse, transactionsViewModel);
  }, [transactionsResponse, transactionsPresenter]);

  // Handle error states
  if (transactionsViewModel?.mode === 'kaboom') {
    return (
      <DefaultError
        locale={currentLocale}
        onRetry={() => refetchTransactions()}
      />
    );
  }

  if (transactionsViewModel?.mode === 'not-found') {
    return (
      <DefaultError
        locale={currentLocale}
        onRetry={() => refetchTransactions()}
      />
    );
  }

  // Loading state
  if (!transactionsViewModel) {
    return <DefaultLoading locale={currentLocale} variant="minimal" />;
  }

  // Get all transactions from view model, sorted by date (newest first)
  const getAllTransactions = () => {
    if (transactionsViewModel.mode !== 'default') {
      return [];
    }
    const transactions = transactionsViewModel.data.transactions || [];
    return [...transactions].sort((a, b) =>
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  };

  // Handler for invoice download/generation
  const handleInvoiceClick = async (transactionId: string | number) => {
    const allTransactions = getAllTransactions();
    const transaction = allTransactions.find((t: any) => t.id === transactionId);

    if (!transaction) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: t('transactionNotFound'),
      });
      return;
    }

    // Check if personal profile API call was successful
    if (!(personalProfileResponse as any)?.success) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: t('customerDataFetchFailed'),
      });
      return;
    }

    // Get coach's own profile data (guaranteed to exist after success check)
    const personalProfile = (personalProfileResponse as any).data?.profile;

    // Validate that customer has filled in required profile fields
    const missingProfileFields: string[] = [];
    if (!personalProfile?.name?.trim()) missingProfileFields.push(t('fieldFirstName'));
    if (!personalProfile?.surname?.trim()) missingProfileFields.push(t('fieldSurname'));

    if (missingProfileFields.length > 0) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: `${t('customerDataMissing')} ${t('missingFieldsLabel')} ${missingProfileFields.join(', ')}`,
      });
      return;
    }

    // Validate that platform has required company information for invoice
    // Check for null, undefined, or empty string and show which fields are missing
    const missingFields: string[] = [];
    if (!platform.companyName?.trim()) missingFields.push(t('fieldCompanyName'));
    if (!platform.companyAddress?.trim()) missingFields.push(t('fieldCompanyAddress'));
    if (!platform.companyUuid?.trim()) missingFields.push(t('fieldCompanyUuid'));

    if (missingFields.length > 0) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: `${t('platformDataMissing')} ${t('missingFieldsLabel')} ${missingFields.join(', ')}`,
      });
      return;
    }

    setIsGeneratingPdf(String(transactionId));

    try {
      // Transform transaction to match InvoiceTransactionData interface
      // Map API response fields to the expected invoice format
      // Note: Outgoing transactions (coach receiving payment) are always type "coachPayment"
      const invoiceTransaction = {
        id: transaction.id,
        createdAt: transaction.createdAt,
        currency: transaction.currency,
        content: {
          type: 'coachingOffers' as const, // Map "coachPayment" to "coachingOffers" for invoice generator
          unitPrice: 0, // Not used for coaching offers, calculated from items
          items: transaction.content.items.map((item: any) => ({
            title: item.description,
            duration: item.duration || '0',
            unitPrice: item.unitPrice,
            quantity: item.quantity,
          })),
        },
      };

      // Use the reusable invoice PDF generator utility
      // For received payments (coach perspective), show the coach's information
      await generateInvoicePdf({
        transaction: invoiceTransaction,
        platformData: {
          name: platform.name,
          logoUrl: platform.logo?.downloadUrl || '',
          domainName: platform.domainName,
          companyName: platform.companyName!,
          companyAddress: platform.companyAddress!,
          companyUid: platform.companyUuid!,
        },
        customerData: {
          name: personalProfile.name!,
          surname: personalProfile.surname!,
          email: personalProfile?.email,
          phone: personalProfile?.phone,
          companyDetails: personalProfile?.companyDetails,
        },
        locale: currentLocale,
        translations: {
          invoiceNo: t('invoice.invoiceNo'),
          invoiceDate: t('invoice.invoiceDate'),
          customerDetails: t('invoice.customerDetails'),
          fullName: t('invoice.fullName'),
          email: t('invoice.email'),
          phoneNumber: t('invoice.phoneNumber'),
          companyName: t('invoice.companyName'),
          companyUidVat: t('invoice.companyUidVat'),
          companyEmail: t('invoice.companyEmail'),
          companyAddress: t('invoice.companyAddress'),
          orderId: t('invoice.orderId'),
          pricePerUnit: t('invoice.pricePerUnit'),
          units: t('invoice.units'),
          total: t('invoice.total'),
          course: t('invoice.course'),
          coachingSession: t('invoice.coachingSession'),
          package: t('invoice.package'),
          totalLabel: t('invoice.totalLabel'),
          paymentMethod: t('invoice.paymentMethod'),
          type: t('invoice.type'),
          description: t('invoice.description'),
          coupon: '',
          discount: '',
        },
      });
    } catch (error: any) {
      setErrorModal({
        isOpen: true,
        title: t('invoiceGenerationFailed'),
        message: t('invoiceGenerationError'),
      });
    } finally {
      setIsGeneratingPdf(null);
    }
  };

  // Transform transactions data to ReceivedPaymentsCard props
  const renderPaymentCards = () => {
    const transactions = getAllTransactions();

    if (transactions.length === 0) {
      return null;
    }

    // Only render the visible transactions based on pagination
    const visibleTransactions = transactions.slice(0, visibleCount);

    return visibleTransactions.map((transaction: any) => {
      // Calculate total from items
      const total = transaction.content.items.reduce((sum: number, item: any) =>
        sum + (item.unitPrice * item.quantity), 0
      );

      // Format items for display
      const items = transaction.content.items.map((item: any) =>
        `${item.quantity}x ${item.description} (${item.unitPrice} ${transaction.currency})`
      );

      // Format date
      const formattedDate = new Date(transaction.createdAt).toLocaleDateString(getLocaleCountryCode(currentLocale));

      return (
        <ReceivedPaymentsCard
          key={transaction.id}
          locale={currentLocale}
          transactionId={String(transaction.id)}
          transactionDate={formattedDate}
          total={`${total.toFixed(2)} ${transaction.currency}`}
          items={items}
          tags={transaction.tag ? [transaction.tag.name] : []}
          onInvoiceClick={() => handleInvoiceClick(transaction.id)}
        />
      );
    });
  };

  const allTransactions = getAllTransactions();
  const hasMore = visibleCount < allTransactions.length;

  const handleLoadMore = () => {
    setVisibleCount(prev => prev + ITEMS_PER_PAGE);
  };

  return (
    <>
      <div className="flex flex-col gap-6">
        <ReceivedPaymentsCardList locale={currentLocale}>
          {renderPaymentCards()}
        </ReceivedPaymentsCardList>

        {hasMore && (
          <div className="flex justify-center">
            <Button
              variant="secondary"
              size="medium"
              text={t('loadMore')}
              onClick={handleLoadMore}
            />
          </div>
        )}
      </div>

      <ConfirmationModal
        type="accept"
        isOpen={errorModal.isOpen}
        onClose={() => setErrorModal({ ...errorModal, isOpen: false })}
        onConfirm={() => setErrorModal({ ...errorModal, isOpen: false })}
        title={errorModal.title}
        message={errorModal.message}
        confirmText="OK"
        locale={currentLocale}
      />
    </>
  );
}
