'use client';

// Auto-generated by page-scaffold command v2 - Refactored
// Notion: https://www.notion.so/Received-payments-Orders-Payments-Coach-workspace-2925a7432d01807fb248fc457b865e8d
// Usecases from Notion: listUserOutgoingTransactions, generateInvoicePdf
// Features from Notion: View received payments from students, Generate/Download invoices
// User Types from Notion: Coach
// Figma: https://www.figma.com/design/8KEwRuOoD5IgxTtFAtLlyS/Just_Do_Ad-1.2?node-id=7709-235261

import { useLocale, useTranslations } from 'next-intl';
import { TLocale } from '@maany_shr/e-class-translations';
import { trpc } from '../trpc/cms-client';
import { ReceivedPaymentsCard, ReceivedPaymentsCardList, Button, ConfirmationModal } from '@maany_shr/e-class-ui-kit';
import { useState } from 'react';
import { generateInvoicePdf } from '../utils/generate-invoice-pdf';
import { getLocaleCountryCode } from '../utils/locale-mapping';

interface ReceivedPaymentsTabProps {
  locale: TLocale;
}

export default function ReceivedPaymentsTab({ locale }: ReceivedPaymentsTabProps) {
  const t = useTranslations('pages.receivedPayments');
  const currentLocale = useLocale() as TLocale;

  // Pagination state - show 8 cards initially (2 rows on desktop with 4 cols)
  const [visibleCount, setVisibleCount] = useState(8);
  const ITEMS_PER_PAGE = 8;
  const [isGeneratingPdf, setIsGeneratingPdf] = useState<string | null>(null);

  // Error modal state
  const [errorModal, setErrorModal] = useState<{
    isOpen: boolean;
    title: string;
    message: string;
  }>({
    isOpen: false,
    title: '',
    message: '',
  });

  // Fetch platform data for invoice branding
  const [platformResponse] = trpc.getPlatform.useSuspenseQuery({});

  // Fetch personal profile for company details in invoice (coach details)
  const [personalProfileResponse] = trpc.getPersonalProfile.useSuspenseQuery({});

  // TRPC query for listUserOutgoingTransactions usecase
  const [transactionsResponse] = trpc.listUserOutgoingTransactions.useSuspenseQuery({});

  // Handle error states
  if (!transactionsResponse.success) {
    const mode = (transactionsResponse as any).mode;

    // Determine which error message to show based on mode
    let errorTitle = t('error.title');
    let errorDescription = t('error.description');

    if (mode === 'kaboom') {
      errorTitle = t('error.kaboom.title');
      errorDescription = t('error.kaboom.description');
    } else if (mode === 'not-found') {
      errorTitle = t('error.notFound.title');
      errorDescription = t('error.notFound.description');
    } else if (mode === 'unauthorized') {
      errorTitle = t('error.unauthorized.title');
      errorDescription = t('error.unauthorized.description');
    }

    return (
      <div className="flex flex-col space-y-3">
        <div className="rounded-lg border border-red-200 bg-red-50 p-4">
          <h3 className="text-lg font-semibold text-red-800">{errorTitle}</h3>
          <p className="text-sm text-red-600 mt-1">{errorDescription}</p>
        </div>
      </div>
    );
  }

  // Get all transactions
  const getAllTransactions = () => {
    const responseData = transactionsResponse.data as { transactions: any[] };
    return responseData.transactions || [];
  };

  // Handler for invoice download/generation
  const handleInvoiceClick = async (transactionId: string | number) => {
    const allTransactions = getAllTransactions();
    const transaction = allTransactions.find((t: any) => t.id === transactionId);

    if (!transaction) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: t('transactionNotFound'),
      });
      return;
    }

    // Check if platform API call was successful
    if (!(platformResponse as any)?.success) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: t('platformDataFetchFailed'),
      });
      return;
    }

    // Check if personal profile API call was successful
    if (!(personalProfileResponse as any)?.success) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: t('customerDataFetchFailed'),
      });
      return;
    }

    // Get platform data (guaranteed to exist after success check)
    const platformData = (platformResponse as any).data;

    // Get coach's own profile data (guaranteed to exist after success check)
    const personalProfile = (personalProfileResponse as any).data?.profile;

    // Validate that customer has filled in required profile fields
    if (!personalProfile?.name || !personalProfile?.surname) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: t('customerDataMissing'),
      });
      return;
    }

    setIsGeneratingPdf(String(transactionId));

    try {
      // Transform the outgoing transaction to match the invoice PDF generator format
      // For outgoing transactions (coach receiving payment), we need to adapt the data structure
      const transformedTransaction = {
        id: transaction.id,
        createdAt: transaction.createdAt,
        currency: transaction.currency,
        content: {
          type: 'coachingOffers' as const, // Outgoing transactions are coaching payments
          unitPrice: 0, // Will be calculated from items
          items: transaction.content.items.map((item: any) => ({
            title: item.description,
            duration: item.duration || '0',
            unitPrice: item.unitPrice,
            quantity: item.quantity,
          })),
        },
      };

      // Use the reusable invoice PDF generator utility
      // For received payments (coach perspective), show the coach's information
      await generateInvoicePdf({
        transaction: transformedTransaction,
        platformData: {
          name: platformData.name,
          logoUrl: platformData.logoUrl,
          domainName: platformData.domainName,
        },
        customerData: {
          name: personalProfile.name,
          surname: personalProfile.surname,
          email: personalProfile?.email,
          phone: personalProfile?.phone,
          companyDetails: personalProfile?.companyDetails,
        },
        locale: currentLocale,
        translations: {
          invoiceNo: t('invoice.invoiceNo'),
          invoiceDate: t('invoice.invoiceDate'),
          customerDetails: t('invoice.customerDetails'),
          fullName: t('invoice.fullName'),
          email: t('invoice.email'),
          phoneNumber: t('invoice.phoneNumber'),
          companyName: t('invoice.companyName'),
          companyUidVat: t('invoice.companyUidVat'),
          companyEmail: t('invoice.companyEmail'),
          companyAddress: t('invoice.companyAddress'),
          orderId: t('invoice.orderId'),
          pricePerUnit: t('invoice.pricePerUnit'),
          units: t('invoice.units'),
          total: t('invoice.total'),
          course: t('invoice.course'),
          coachingSession: t('invoice.coachingSession'),
          package: t('invoice.package'),
          totalLabel: t('invoice.totalLabel'),
          paymentMethod: t('invoice.paymentMethod'),
        },
      });
    } catch (error: any) {
      setErrorModal({
        isOpen: true,
        title: t('invoiceGenerationFailed'),
        message: t('invoiceGenerationError'),
      });
    } finally {
      setIsGeneratingPdf(null);
    }
  };

  // Transform transactions data to ReceivedPaymentsCard props
  const renderPaymentCards = () => {
    const transactions = getAllTransactions();

    if (transactions.length === 0) {
      return null;
    }

    // Only render the visible transactions based on pagination
    const visibleTransactions = transactions.slice(0, visibleCount);

    return visibleTransactions.map((transaction: any) => {
      // Calculate total from items
      const total = transaction.content.items.reduce((sum: number, item: any) =>
        sum + (item.unitPrice * item.quantity), 0
      );

      // Format items for display
      const items = transaction.content.items.map((item: any) =>
        `${item.quantity}x ${item.description} (${item.unitPrice} ${transaction.currency})`
      );

      // Format date
      const formattedDate = new Date(transaction.createdAt).toLocaleDateString(getLocaleCountryCode(currentLocale));

      return (
        <ReceivedPaymentsCard
          key={transaction.id}
          locale={currentLocale}
          transactionId={String(transaction.id)}
          transactionDate={formattedDate}
          total={`${total.toFixed(2)} ${transaction.currency}`}
          items={items}
          tags={transaction.tag ? [transaction.tag.name] : []}
          onInvoiceClick={() => handleInvoiceClick(transaction.id)}
        />
      );
    });
  };

  const allTransactions = getAllTransactions();
  const hasMore = visibleCount < allTransactions.length;

  const handleLoadMore = () => {
    setVisibleCount(prev => prev + ITEMS_PER_PAGE);
  };

  return (
    <>
      <div className="flex flex-col gap-6">
        <ReceivedPaymentsCardList locale={currentLocale}>
          {renderPaymentCards()}
        </ReceivedPaymentsCardList>

        {hasMore && (
          <div className="flex justify-center">
            <Button
              variant="secondary"
              size="medium"
              text={t('loadMore')}
              onClick={handleLoadMore}
            />
          </div>
        )}
      </div>

      <ConfirmationModal
        type="accept"
        isOpen={errorModal.isOpen}
        onClose={() => setErrorModal({ ...errorModal, isOpen: false })}
        onConfirm={() => setErrorModal({ ...errorModal, isOpen: false })}
        title={errorModal.title}
        message={errorModal.message}
        confirmText="OK"
        locale={currentLocale}
      />
    </>
  );
}
