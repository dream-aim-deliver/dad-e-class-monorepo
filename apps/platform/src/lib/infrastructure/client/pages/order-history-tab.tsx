'use client';

// Auto-generated by page-scaffold command v2 - Refactored
// Notion: https://www.notion.so/Order-history-Orders-Payments-Student-workspace-6bb2794c7331418e8fbbf83c40dcb1e5
// Usecases from Notion: listUserIncomingTransactions, generateInvoicePdf
// Features from Notion: View transaction history, Download/Generate invoices
// User Types from Notion: Student, Coach
// Figma: https://www.figma.com/design/8KEwRuOoD5IgxTtFAtLlyS/Just_Do_Ad-1.2?node-id=7709-215954

import { useLocale, useTranslations } from 'next-intl';
import { TLocale } from '@maany_shr/e-class-translations';
import { trpc } from '../trpc/cms-client';
import { OrderHistoryCard, OrderHistoryCardList, Button, ConfirmationModal, DefaultError, DefaultLoading } from '@maany_shr/e-class-ui-kit';
import { useState, useEffect } from 'react';
import { useSession } from 'next-auth/react';
import { useRouter } from 'next/navigation';
import { generateInvoicePdf } from '../utils/generate-invoice-pdf';
import { getLocaleCountryCode } from '../utils/locale-mapping';
import { useRequiredPlatform } from '../context/platform-context';
import { viewModels } from '@maany_shr/e-class-models';
import { useListUserIncomingTransactionsPresenter } from '../hooks/use-list-user-incoming-transactions-presenter';

interface OrderHistoryTabProps {
  locale: TLocale;
}

export default function OrderHistoryTab({ locale }: OrderHistoryTabProps) {
  const t = useTranslations('pages.orderHistory');
  const currentLocale = useLocale() as TLocale;
  const { data: session } = useSession();
  const router = useRouter();
  const { platform } = useRequiredPlatform();

  // Pagination state - show 8 cards initially (2 rows on desktop with 4 cols)
  const [visibleCount, setVisibleCount] = useState(8);
  const ITEMS_PER_PAGE = 8;
  const [isGeneratingPdf, setIsGeneratingPdf] = useState<string | null>(null);

  // Error modal state
  const [errorModal, setErrorModal] = useState<{
    isOpen: boolean;
    title: string;
    message: string;
  }>({
    isOpen: false,
    title: '',
    message: '',
  });

  // Fetch personal profile for customer details in invoice
  const [personalProfileResponse] = trpc.getPersonalProfile.useSuspenseQuery({});

  // TRPC query for listUserIncomingTransactions usecase
  const [transactionsResponse, { refetch: refetchTransactions }] = trpc.listUserIncomingTransactions.useSuspenseQuery({});

  // View model state
  const [transactionsViewModel, setTransactionsViewModel] = useState<
    viewModels.TListUserIncomingTransactionsViewModel | undefined
  >(undefined);

  // Presenter
  const { presenter: transactionsPresenter } = useListUserIncomingTransactionsPresenter(
    setTransactionsViewModel,
  );

  // Present the data when response changes
  useEffect(() => {
    // @ts-ignore
    transactionsPresenter.present(transactionsResponse, transactionsViewModel);
  }, [transactionsResponse, transactionsPresenter]);

  // Handle error states
  if (transactionsViewModel?.mode === 'kaboom') {
    return (
      <DefaultError
        locale={currentLocale}
        onRetry={() => refetchTransactions()}
      />
    );
  }

  if (transactionsViewModel?.mode === 'not-found') {
    return (
      <DefaultError
        locale={currentLocale}
        onRetry={() => refetchTransactions()}
      />
    );
  }

  // Loading state
  if (!transactionsViewModel) {
    return <DefaultLoading locale={currentLocale} variant="minimal" />;
  }

  // Get all transactions from view model, sorted by date (newest first)
  const getAllTransactions = () => {
    if (transactionsViewModel.mode !== 'default') {
      return [];
    }
    const transactions = transactionsViewModel.data.transactions || [];
    return [...transactions].sort((a, b) =>
      new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
    );
  };

  // Handler for invoice download/generation
  const handleInvoiceClick = async (transactionId: string | number) => {
    const allTransactions = getAllTransactions();
    const transaction = allTransactions.find((t: any) => t.id === transactionId);

    if (!transaction) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: t('transactionNotFound'),
      });
      return;
    }

    // Check if personal profile API call was successful
    if (!(personalProfileResponse as any)?.success) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: t('customerDataFetchFailed'),
      });
      return;
    }

    // Get customer data (guaranteed to exist after success check)
    const personalProfile = (personalProfileResponse as any).data?.profile;

    // Validate that customer has filled in required profile fields
    if (!personalProfile?.name || !personalProfile?.surname) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: t('customerDataMissing'),
      });
      return;
    }

    // Validate that platform has required company information for invoice
    // Check for null, undefined, or empty string
    if (!platform.companyName?.trim() || !platform.companyAddress?.trim() || !platform.companyUuid?.trim()) {
      setErrorModal({
        isOpen: true,
        title: t('error.title'),
        message: t('platformDataMissing'),
      });
      return;
    }

    setIsGeneratingPdf(String(transactionId));

    try {
      // Transform transaction to match InvoiceTransactionData interface
      // Map API response fields to the expected invoice format
      const invoiceTransaction = {
        id: transaction.id,
        createdAt: transaction.createdAt,
        currency: transaction.currency,
        content: {
          type: transaction.content.type,
          unitPrice: transaction.content.type === 'coachingOffers' ? 0 : transaction.content.unitPrice,
          ...(transaction.content.type === 'course' && transaction.content.course && {
            course: {
              title: transaction.content.course.title,
              id: transaction.content.course.id,
            },
          }),
          ...(transaction.content.type === 'coachingOffers' && {
            items: transaction.content.items,
          }),
          ...(transaction.content.type === 'package' && transaction.content.package && {
            package: {
              title: transaction.content.package.title,
              id: transaction.content.package.id,
            },
          }),
        },
      };

      // Use the reusable invoice PDF generator utility
      await generateInvoicePdf({
        transaction: invoiceTransaction,
        platformData: {
          name: platform.name,
          logoUrl: platform.logo?.downloadUrl || '',
          domainName: platform.domainName,
          companyName: platform.companyName,
          companyAddress: platform.companyAddress,
          companyUid: platform.companyUuid,
        },
        customerData: {
          name: personalProfile.name,
          surname: personalProfile.surname,
          email: personalProfile?.email,
          phone: personalProfile?.phone,
          companyDetails: personalProfile?.companyDetails,
        },
        locale: currentLocale,
        translations: {
          invoiceNo: t('invoice.invoiceNo'),
          invoiceDate: t('invoice.invoiceDate'),
          customerDetails: t('invoice.customerDetails'),
          fullName: t('invoice.fullName'),
          email: t('invoice.email'),
          phoneNumber: t('invoice.phoneNumber'),
          companyName: t('invoice.companyName'),
          companyUidVat: t('invoice.companyUidVat'),
          companyEmail: t('invoice.companyEmail'),
          companyAddress: t('invoice.companyAddress'),
          orderId: t('invoice.orderId'),
          pricePerUnit: t('invoice.pricePerUnit'),
          units: t('invoice.units'),
          total: t('invoice.total'),
          course: t('invoice.course'),
          coachingSession: t('invoice.coachingSession'),
          package: t('invoice.package'),
          totalLabel: t('invoice.totalLabel'),
          paymentMethod: t('invoice.paymentMethod'),
          type: t('invoice.type'),
          description: t('invoice.description'),
        },
      });
    } catch (error: any) {
      setErrorModal({
        isOpen: true,
        title: t('invoiceGenerationFailed'),
        message: t('invoiceGenerationError'),
      });
    } finally {
      setIsGeneratingPdf(null);
    }
  };

  // Transform transactions data to OrderHistoryCard props
  const renderOrderCards = () => {
    const transactions = getAllTransactions();

    if (transactions.length === 0) {
      return null;
    }

    // Only render the visible transactions based on pagination
    const visibleTransactions = transactions.slice(0, visibleCount);

    return visibleTransactions.map((transaction: any) => {
      // Determine the transaction type based on content.type
      const orderType = transaction.content.type;

      if (orderType === 'course') {
        const course = transaction.content.course;
        return (
          <OrderHistoryCard
            key={transaction.id}
            locale={currentLocale}
            type="course"
            orderId={transaction.id}
            orderDate={new Date(transaction.createdAt).toLocaleString(getLocaleCountryCode(currentLocale), {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            })}
            total={`${transaction.content.unitPrice} ${transaction.currency}`}
            courseTitle={course.title}
            courseImageUrl={course.imageUrl || ''}
            coachingSessionCount={course.coachingSessionCount}
            onClickCourse={() => {
              router.push(`/courses/${course.slug}`);
            }}
            onInvoiceClick={() => handleInvoiceClick(transaction.id)}
          />
        );
      }

      if (orderType === 'coachingOffers') {
        const coachingContent = transaction.content;
        // Calculate total price from all items
        const totalPrice = coachingContent.items.reduce((sum: number, item: any) =>
          sum + (item.unitPrice * item.quantity), 0);

        // Transform coaching items from the API to match our component structure
        const sessions = coachingContent.items.map((item: any) => ({
          sessionName: item.title,
          durationMinutes: parseInt(item.duration) || 0,
          count: item.quantity,
        }));

        return (
          <OrderHistoryCard
            key={transaction.id}
            locale={currentLocale}
            type="coaching"
            orderId={transaction.id}
            orderDate={new Date(transaction.createdAt).toLocaleString(getLocaleCountryCode(currentLocale), {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            })}
            total={`${totalPrice} ${transaction.currency}`}
            sessions={sessions}
            onInvoiceClick={() => handleInvoiceClick(transaction.id)}
          />
        );
      }

      if (orderType === 'package') {
        const pkg = transaction.content.package;
        // Transform courses included in the package
        const coursesIncluded = transaction.content.coursesIncluded?.map((course: any) => ({
          title: course.title,
          imageUrl: course.imageUrl || '',
          onClick: () => {
            router.push(`/courses/${course.slug}`);
          },
        })) || [];

        return (
          <OrderHistoryCard
            key={transaction.id}
            locale={currentLocale}
            type="package"
            orderId={transaction.id}
            orderDate={new Date(transaction.createdAt).toLocaleString(getLocaleCountryCode(currentLocale), {
              year: 'numeric',
              month: '2-digit',
              day: '2-digit',
              hour: '2-digit',
              minute: '2-digit'
            })}
            total={`${transaction.content.unitPrice} ${transaction.currency}`}
            packageTitle={pkg.title}
            packageImageUrl={pkg.imageUrl || ''}
            coursesIncluded={coursesIncluded}
            onInvoiceClick={() => handleInvoiceClick(transaction.id)}
          />
        );
      }

      return null;
    });
  };

  const allTransactions = getAllTransactions();
  const hasMore = visibleCount < allTransactions.length;

  const handleLoadMore = () => {
    setVisibleCount(prev => prev + ITEMS_PER_PAGE);
  };

  return (
    <>
      <div className="flex flex-col gap-6">
        <OrderHistoryCardList locale={currentLocale}>
          {renderOrderCards()}
        </OrderHistoryCardList>

        {hasMore && (
          <div className="flex justify-center">
            <Button
              variant="secondary"
              size="medium"
              text={t('loadMore')}
              onClick={handleLoadMore}
            />
          </div>
        )}
      </div>

      <ConfirmationModal
        type="accept"
        isOpen={errorModal.isOpen}
        onClose={() => setErrorModal({ ...errorModal, isOpen: false })}
        onConfirm={() => setErrorModal({ ...errorModal, isOpen: false })}
        title={errorModal.title}
        message={errorModal.message}
        confirmText="OK"
        locale={currentLocale}
      />
    </>
  );
}
