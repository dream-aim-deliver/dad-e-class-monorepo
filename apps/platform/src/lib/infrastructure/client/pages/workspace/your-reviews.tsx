'use client';

// Auto-generated by page-scaffold command
// Notion: https://www.notion.so/Reviews-Coach-Workspace-bd0adcab71d04c1abc9a71852b879d9c
// Features: listCoachReviews
// API Endpoints: GET /{api_version}/{platform_id}/user/{user_id}/reviews
// User Types: Coach
// Figma: https://www.figma.com/design/8KEwRuOoD5IgxTtFAtLlyS/Just_Do_Ad-1.2?node-id=7671-262871&t=n19jujPl9CMQvyEQ-4
// TSK: TSK-1451

import { TLocale } from '@maany_shr/e-class-translations';
import { useLocale, useTranslations } from 'next-intl';
import { useState, useEffect, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { trpc } from '../../trpc/cms-client';
import { viewModels, useCaseModels } from '@maany_shr/e-class-models';
import { useListCoachReviewsPresenter } from '../../hooks/use-list-coach-reviews-presenter';
import { TEClassRole } from '@dream-aim-deliver/e-class-cms-rest';
import {
    Breadcrumbs,
    Button,
    DefaultLoading,
    DefaultError,
    DefaultNotFound,
    CoachReviewCard,
    CardListLayout,
    Dropdown,
    Dialog,
    DialogTrigger,
    DialogContent,
    DialogBody,
    ReviewFilterModal,
    ReviewFilterModel,
    IconClose,
} from '@maany_shr/e-class-ui-kit';
import { useSession } from 'next-auth/react';
import useClientSidePagination from '../../utils/use-client-side-pagination';

interface YourReviewsProps {
    roles: TEClassRole[];
}

type SortOption = 'most-recent' | 'oldest' | 'best' | 'worst';

export default function YourReviews({ roles }: YourReviewsProps) {
    const locale = useLocale() as TLocale;
    const t = useTranslations('pages.yourReviews');
    const breadcrumbsTranslations = useTranslations('components.breadcrumbs');
    const router = useRouter();

    const sessionDTO = useSession();
    const session = sessionDTO.data;
    const isLoggedIn = !!session;

    // Filter and sort states
    const [isFilterModalOpen, setIsFilterModalOpen] = useState(false);
    const [appliedFilters, setAppliedFilters] = useState<ReviewFilterModel>({});
    const [sortBy, setSortBy] = useState<SortOption>('most-recent');

    // Fetch coach reviews using the logged-in coach's username
    const [coachReviewsResponse] = trpc.listCoachReviews.useSuspenseQuery({
        coachUsername: session?.user?.name || '',
    });

    const [coachReviewsViewModel, setCoachReviewsViewModel] = useState<
        viewModels.TListCoachReviewsViewModel | undefined
    >(undefined);

    const { presenter } = useListCoachReviewsPresenter(
        setCoachReviewsViewModel,
    );

    // Present the data when response is available
    useEffect(() => {
        if (coachReviewsResponse && presenter) {
            // tRPC response is already in the correct format, no unwrapping needed
            // tRPC wrapper types don't match presenter expectations exactly
            presenter.present(
                // @ts-ignore
                coachReviewsResponse,
                coachReviewsViewModel,
            );
        }
    }, [coachReviewsResponse, presenter, coachReviewsViewModel]);

    // Extract reviews data - safe access before early returns
    const reviewsData =
        coachReviewsViewModel?.mode === 'default'
            ? (coachReviewsViewModel.data as viewModels.TListCoachReviewsSuccess)
            : null;
    const allReviews = reviewsData?.reviews || [];

    // Apply filters and sorting using useMemo
    const sortedAndFilteredReviews = useMemo(() => {
        let filtered = [...allReviews];

        // Filter by rating
        if (appliedFilters.minRating !== undefined) {
            filtered = filtered.filter(
                (review) => review.rating >= appliedFilters.minRating!,
            );
        }
        if (appliedFilters.maxRating !== undefined) {
            filtered = filtered.filter(
                (review) => review.rating <= appliedFilters.maxRating!,
            );
        }

        // Filter by student name
        if (appliedFilters.studentName && appliedFilters.studentName.trim()) {
            const searchTerm = appliedFilters.studentName.toLowerCase().trim();
            filtered = filtered.filter((review) => {
                const fullName =
                    `${review.student.name} ${review.student.surname}`.toLowerCase();
                return fullName.includes(searchTerm);
            });
        }

        // Filter by course name
        if (appliedFilters.courseName && appliedFilters.courseName.trim()) {
            const searchTerm = appliedFilters.courseName.toLowerCase().trim();
            filtered = filtered.filter((review) =>
                review.course?.title?.toLowerCase().includes(searchTerm),
            );
        }

        // Filter by date range
        if (appliedFilters.dateAfter) {
            const afterDate = new Date(appliedFilters.dateAfter);
            filtered = filtered.filter((review) => {
                const reviewDate = new Date(review.coachingSession.startTime);
                return reviewDate >= afterDate;
            });
        }
        if (appliedFilters.dateBefore) {
            const beforeDate = new Date(appliedFilters.dateBefore);
            filtered = filtered.filter((review) => {
                const reviewDate = new Date(review.coachingSession.startTime);
                return reviewDate <= beforeDate;
            });
        }

        // Sort reviews
        const sorted = [...filtered];
        switch (sortBy) {
            case 'most-recent':
                sorted.sort((a, b) => {
                    const dateA = new Date(
                        a.coachingSession.startTime,
                    ).getTime();
                    const dateB = new Date(
                        b.coachingSession.startTime,
                    ).getTime();
                    return dateB - dateA; // Newest first
                });
                break;
            case 'oldest':
                sorted.sort((a, b) => {
                    const dateA = new Date(
                        a.coachingSession.startTime,
                    ).getTime();
                    const dateB = new Date(
                        b.coachingSession.startTime,
                    ).getTime();
                    return dateA - dateB; // Oldest first
                });
                break;
            case 'best':
                sorted.sort((a, b) => b.rating - a.rating); // Highest rating first
                break;
            case 'worst':
                sorted.sort((a, b) => a.rating - b.rating); // Lowest rating first
                break;
        }

        return sorted;
    }, [allReviews, appliedFilters, sortBy]);

    // Client-side pagination - 4 cards per line, 2 lines = 8 reviews
    // This hook must be called before any early returns
    const {
        displayedItems: displayedReviews,
        hasMoreItems,
        handleLoadMore,
    } = useClientSidePagination({
        items: sortedAndFilteredReviews,
        itemsPerPage: 8, // 4 cards x 2 lines for smaller screens
        itemsPerPage2xl: 8, // 4 cards x 2 lines for 2xl screens
    });

    // Loading state
    if (!coachReviewsViewModel) {
        return <DefaultLoading locale={locale} variant="minimal" />;
    }

    // Error handling - kaboom (hard error)
    if (coachReviewsViewModel.mode === 'kaboom') {
        return (
            <DefaultError
                type="simple"
                locale={locale}
                title={t('error.title')}
                description={t('error.description')}
            />
        );
    }

    // Error handling - not found
    if (coachReviewsViewModel.mode === 'not-found') {
        return <DefaultNotFound locale={locale} />;
    }

    // Check if filters are active
    const hasActiveFilters =
        appliedFilters.minRating !== undefined ||
        appliedFilters.maxRating !== undefined ||
        (appliedFilters.studentName &&
            appliedFilters.studentName.trim() !== '') ||
        (appliedFilters.courseName &&
            appliedFilters.courseName.trim() !== '') ||
        appliedFilters.dateAfter ||
        appliedFilters.dateBefore;

    const handleApplyFilters = (filters: ReviewFilterModel) => {
        setAppliedFilters(filters);
    };

    const handleClearFilters = () => {
        setAppliedFilters({});
    };

    const sortOptions = [
        { label: t('sortMostRecent'), value: 'most-recent' },
        { label: t('sortOldest'), value: 'oldest' },
        { label: t('sortBest'), value: 'best' },
        { label: t('sortWorst'), value: 'worst' },
    ];

    const breadcrumbItems = [
        {
            label: breadcrumbsTranslations('home'),
            onClick: () => router.push(`/${locale}`),
        },
        {
            label: breadcrumbsTranslations('workspace'),
            onClick: () => router.push(`/${locale}/workspace/`),
        },
        {
            label: breadcrumbsTranslations('yourReviews'),
            onClick: () => {
                // Nothing should happen on clicking the current page
            },
        },
    ];

    return (
        <div className="flex flex-col space-y-2">
            <Breadcrumbs items={breadcrumbItems} />

            <div className="flex flex-col space-y-4 sm:space-y-0 sm:flex-row sm:justify-between sm:items-center">
                <div className="flex flex-col mb-4">
                    <h1>{t('title')}</h1>
                    {hasActiveFilters && (
                        <Button
                            variant="text"
                            size="small"
                            onClick={handleClearFilters}
                            text={t('clearFilters')}
                            className="self-start mt-1"
                            hasIconLeft
                            iconLeft={<IconClose />}
                        />
                    )}
                </div>
                <div className="flex flex-col sm:flex-row gap-3 sm:items-center">
                    <p className="text-text-primary text-sm"> {t('sortBy')} </p>
                    <div className="min-w-[200px]">
                        <Dropdown
                            type="simple"
                            options={sortOptions}
                            onSelectionChange={(selected) =>
                                setSortBy(selected as SortOption)
                            }
                            text={{ simpleText: t('sortBy') }}
                            defaultValue={sortBy}
                        />
                    </div>
                    <div className="flex gap-2">
                        <Dialog
                            open={isFilterModalOpen}
                            onOpenChange={setIsFilterModalOpen}
                            defaultOpen={false}
                        >
                            <DialogTrigger asChild>
                                <Button
                                    variant="secondary"
                                    size="medium"
                                    onClick={() => setIsFilterModalOpen(true)}
                                    text={t('filterButton')}
                                />
                            </DialogTrigger>
                            <DialogContent
                                showCloseButton={false}
                                closeOnOverlayClick={true}
                                closeOnEscape={true}
                            >
                                <DialogBody>
                                    <ReviewFilterModal
                                        locale={locale}
                                        onApplyFilters={handleApplyFilters}
                                        onClose={() =>
                                            setIsFilterModalOpen(false)
                                        }
                                        initialFilters={appliedFilters}
                                    />
                                </DialogBody>
                            </DialogContent>
                        </Dialog>
                    </div>
                </div>
            </div>

            {sortedAndFilteredReviews.length === 0 ? (
                <div className="flex flex-col md:p-5 p-3 gap-2 rounded-medium border border-card-stroke bg-card-fill w-full">
                    <p className="text-text-primary text-md">
                        {hasActiveFilters
                            ? t('noReviewsFiltered')
                            : t('noReviews')}
                    </p>
                </div>
            ) : (
                <>
                    <CardListLayout className="xl:grid-cols-4">
                        {displayedReviews.map((review, index: number) => {
                            const baseProps = {
                                locale,
                                rating: review.rating,
                                reviewerName: review.student.username,
                                reviewerAvatar: review.student.avatarImage?.downloadUrl,
                                reviewText: review.notes || '',
                                workshopTitle: review.coachingSession.coachingOfferingTitle,
                                date: new Date(review.coachingSession.startTime),
                                time: new Date(review.coachingSession.startTime).toLocaleTimeString(locale, {
                                    hour: '2-digit',
                                    minute: '2-digit',
                                }),
                                onClickReviewer: () => window.open(`/${locale}/students/${review.student.username}`, '_blank'),
                            };

                            if (review.course) {
                                return (
                                    <CoachReviewCard
                                        key={review.id || index}
                                        {...baseProps}
                                        type="with-course"
                                        courseTitle={review.course.title || ''}
                                        courseImage={review.course.image?.downloadUrl || ''}
                                    />
                                );
                            }

                            return (
                                <CoachReviewCard
                                    key={review.id || index}
                                    {...baseProps}
                                    type="standalone"
                                />
                            );
                        })}
                    </CardListLayout>
                    {hasMoreItems && (
                        <div className="flex justify-center items-center w-full mt-6">
                            <Button
                                variant="text"
                                text={t('loadMore')}
                                onClick={handleLoadMore}
                            />
                        </div>
                    )}
                </>
            )}
        </div>
    );
}
