'use client';

// Auto-generated by page-scaffold command
// Notion: https://www.notion.so/Reviews-Coach-Workspace-bd0adcab71d04c1abc9a71852b879d9c
// Features: listCoachReviews
// API Endpoints: GET /{api_version}/{platform_id}/user/{user_id}/reviews
// User Types: Coach
// Figma: https://www.figma.com/design/8KEwRuOoD5IgxTtFAtLlyS/Just_Do_Ad-1.2?node-id=7671-262871&t=n19jujPl9CMQvyEQ-4
// TSK: TSK-1451

import { TLocale } from '@maany_shr/e-class-translations';
import { useLocale, useTranslations } from 'next-intl';
import { useState, useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { trpc } from '../../trpc/cms-client';
import { viewModels, useCaseModels, role } from '@maany_shr/e-class-models';
import { useListCoachReviewsPresenter } from '../../hooks/use-list-coach-reviews-presenter';
import {
    Breadcrumbs,
    Button,
    DefaultLoading,
    DefaultError,
    DefaultNotFound,
    CoachReviewCard,
    CardListLayout,
    Dropdown,
    Dialog,
    DialogTrigger,
    DialogContent,
    DialogBody,
    ReviewFilterModal,
    ReviewFilterModel,
    IconClose,
} from '@maany_shr/e-class-ui-kit';
import { useSession } from 'next-auth/react';

interface YourReviewsProps {
    roles: role.TRole[];
}

type SortOption = 'most-recent' | 'oldest' | 'best' | 'worst';

export default function YourReviews({ roles }: YourReviewsProps) {
    const locale = useLocale() as TLocale;
    const t = useTranslations('pages.yourReviews');
    const breadcrumbsTranslations = useTranslations('components.breadcrumbs');
    const router = useRouter();

    const sessionDTO = useSession();
    const session = sessionDTO.data;
    const isLoggedIn = !!session;
    const isCoach = roles.includes('coach');

    // Filter and sort states
    const [isFilterModalOpen, setIsFilterModalOpen] = useState(false);
    const [appliedFilters, setAppliedFilters] = useState<ReviewFilterModel>({});
    const [sortBy, setSortBy] = useState<SortOption>('most-recent');

    // Fetch coach reviews using the logged-in coach's username
    const [coachReviewsResponse] = trpc.listCoachReviews.useSuspenseQuery({
        coachUsername: session?.user?.name || '',
    });

    const [coachReviewsViewModel, setCoachReviewsViewModel] = useState<
        viewModels.TListCoachReviewsViewModel | undefined
    >(undefined);

	const { presenter: coachReviewsPresenter } = useListCoachReviewsPresenter(
		setCoachReviewsViewModel,
	);

	// @ts-ignore
	coachReviewsPresenter.present(coachReviewsResponse, coachReviewsViewModel);

    // Loading state
    if (!coachReviewsViewModel) {
        return <DefaultLoading locale={locale} variant="minimal" />;
    }

    // Error handling - not found
    if (coachReviewsViewModel.mode === 'not-found') {
        return <DefaultNotFound locale={locale} />;
    }

    // Success state - extract data
    const reviewsData = coachReviewsViewModel.data as any;
    const allReviews = reviewsData?.reviews || [];

    // Filter reviews
    const filterReviews = (reviews: any[]) => {
        let filtered = [...reviews];

        // Filter by rating
        if (appliedFilters.minRating !== undefined) {
            filtered = filtered.filter((review) => review.rating >= appliedFilters.minRating!);
        }
        if (appliedFilters.maxRating !== undefined) {
            filtered = filtered.filter((review) => review.rating <= appliedFilters.maxRating!);
        }

        // Filter by student name
        if (appliedFilters.studentName && appliedFilters.studentName.trim()) {
            const searchTerm = appliedFilters.studentName.toLowerCase().trim();
            filtered = filtered.filter((review) =>
                (review.reviewerName || review.studentName || '').toLowerCase().includes(searchTerm)
            );
        }

        // Filter by course name
        if (appliedFilters.courseName && appliedFilters.courseName.trim()) {
            const searchTerm = appliedFilters.courseName.toLowerCase().trim();
            filtered = filtered.filter((review) =>
                (review.courseTitle || review.courseName || '').toLowerCase().includes(searchTerm)
            );
        }

        // Filter by date range
        if (appliedFilters.dateAfter) {
            const afterDate = new Date(appliedFilters.dateAfter);
            filtered = filtered.filter((review) => {
                const reviewDate = review.date ? new Date(review.date) : new Date();
                return reviewDate >= afterDate;
            });
        }
        if (appliedFilters.dateBefore) {
            const beforeDate = new Date(appliedFilters.dateBefore);
            filtered = filtered.filter((review) => {
                const reviewDate = review.date ? new Date(review.date) : new Date();
                return reviewDate <= beforeDate;
            });
        }

        return filtered;
    };

    // Sort reviews
    const sortReviews = (reviews: any[]) => {
        const sorted = [...reviews];

        switch (sortBy) {
            case 'most-recent':
                sorted.sort((a, b) => {
                    const dateA = a.date ? new Date(a.date).getTime() : 0;
                    const dateB = b.date ? new Date(b.date).getTime() : 0;
                    return dateB - dateA; // Newest first
                });
                break;
            case 'oldest':
                sorted.sort((a, b) => {
                    const dateA = a.date ? new Date(a.date).getTime() : 0;
                    const dateB = b.date ? new Date(b.date).getTime() : 0;
                    return dateA - dateB; // Oldest first
                });
                break;
            case 'best':
                sorted.sort((a, b) => (b.rating || 0) - (a.rating || 0)); // Highest rating first
                break;
            case 'worst':
                sorted.sort((a, b) => (a.rating || 0) - (b.rating || 0)); // Lowest rating first
                break;
        }

        return sorted;
    };

    // Apply filters and sorting
    const filteredReviews = filterReviews(allReviews);
    const sortedAndFilteredReviews = sortReviews(filteredReviews);

    // Check if filters are active
    const hasActiveFilters =
        appliedFilters.minRating !== undefined ||
        appliedFilters.maxRating !== undefined ||
        (appliedFilters.studentName && appliedFilters.studentName.trim() !== '') ||
        (appliedFilters.courseName && appliedFilters.courseName.trim() !== '') ||
        appliedFilters.dateAfter ||
        appliedFilters.dateBefore;

    const handleApplyFilters = (filters: ReviewFilterModel) => {
        setAppliedFilters(filters);
    };

    const handleClearFilters = () => {
        setAppliedFilters({});
    };

    const sortOptions = [
        { label: t('sortMostRecent'), value: 'most-recent' },
        { label: t('sortOldest'), value: 'oldest' },
        { label: t('sortBest'), value: 'best' },
        { label: t('sortWorst'), value: 'worst' },
    ];

    const breadcrumbItems = [
        {
            label: breadcrumbsTranslations('home'),
            onClick: () => router.push('/'),
        },
        {
            label: breadcrumbsTranslations('workspace'),
            onClick: () => {
                // TODO: Implement navigation to workspace
            },
        },
        {
            label: breadcrumbsTranslations('yourReviews'),
            onClick: () => {
                // Nothing should happen on clicking the current page
            },
        },
    ];

    return (
        <div className="flex flex-col space-y-2">
            <Breadcrumbs items={breadcrumbItems} />

            <div className="flex flex-col space-y-4 sm:space-y-0 sm:flex-row sm:justify-between sm:items-center">
                <div className="flex flex-col mb-4">
                    <h1>{t('title')}</h1>
                    {hasActiveFilters && (
                        <Button
                            variant="text"
                            size="small"
                            onClick={handleClearFilters}
                            text={t('clearFilters')}
                            className="self-start mt-1"
                            hasIconLeft
                            iconLeft={<IconClose />}
                        />
                    )}
                </div>
                <div className="flex flex-col sm:flex-row gap-3 sm:items-center">
                    <p className='text-text-primary text-sm'> {t('sortBy')} </p>
                    <div className="min-w-[200px]">
                        <Dropdown
                            type="simple"
                            options={sortOptions}
                            onSelectionChange={(selected) => setSortBy(selected as SortOption)}
                            text={{ simpleText: t('sortBy')}}
                            defaultValue={sortBy}
                        />
                    </div>
                    <div className="flex gap-2">
                        <Dialog
                            open={isFilterModalOpen}
                            onOpenChange={setIsFilterModalOpen}
                            defaultOpen={false}
                        >
                            <DialogTrigger asChild>
                                <Button
                                    variant="secondary"
                                    size="medium"
                                    onClick={() => setIsFilterModalOpen(true)}
                                    text={t('filterButton')}
                                />
                            </DialogTrigger>
                            <DialogContent
                                showCloseButton={false}
                                closeOnOverlayClick={true}
                                closeOnEscape={true}
                                className="mt-10"
                            >
                                <DialogBody>
                                    <ReviewFilterModal
                                        locale={locale}
                                        onApplyFilters={handleApplyFilters}
                                        onClose={() => setIsFilterModalOpen(false)}
                                        initialFilters={appliedFilters}
                                    />
                                </DialogBody>
                            </DialogContent>
                        </Dialog>
                    </div>
                </div>
            </div>

            {sortedAndFilteredReviews.length === 0 ? (
                <div className="flex flex-col md:p-5 p-3 gap-2 rounded-medium border border-card-stroke bg-card-fill w-full">
                    <p className="text-text-primary text-md">
                        {hasActiveFilters
                            ? t('noReviewsFiltered') || 'No reviews match your filters.'
                            : t('noReviews') || 'No reviews yet. Reviews from your coaching sessions will appear here.'}
                    </p>
                </div>
            ) : (
                <CardListLayout>
                    {sortedAndFilteredReviews.map((review: any, index: number) => (
                        <CoachReviewCard
                            key={review.id }
                            locale={locale}
                            rating={review.rating}
                            reviewerName={review.reviewerName || review.studentName}
                            reviewerAvatar={review.reviewerAvatar || review.studentAvatar}
                            reviewText={review.reviewText || review.comment}
                            workshopTitle={review.workshopTitle || review.sessionTitle}
                            date={review.date ? new Date(review.date) : new Date()}
                            time={review.time}
                            courseTitle={review.courseTitle || review.courseName}
                            courseImage={review.courseImage || review.courseImageUrl}
                        />
                    ))}
                </CardListLayout>
            )}
        </div>
    );
}
