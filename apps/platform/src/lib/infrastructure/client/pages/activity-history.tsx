'use client';

// Auto-generated by page-scaffold command v2
// Notion: https://www.notion.so/Activity-history-Notifications-Page-2245a7432d01800e8e33d5d245ae9c4e
// Usecases from Notion: listNotifications, markNotificationsAsRead
// Features from Notion: FEAT-5 (listNotifications), FEAT-95 (markNotificationsAsRead)
// API Endpoints from Notion:
// User Types from Notion: Accessible to all logged-in users
// Figma: https://www.figma.com/design/8KEwRuOoD5IgxTtFAtLlyS/Just_Do_Ad-1.2?node-id=8450-61105&t=z3N6GyoO667IGfSR-4
// Comment: Activity history view uses the already made NotificationGrid

import { useLocale, useTranslations } from 'next-intl';
import { TLocale } from '@maany_shr/e-class-translations';
import { useSession } from 'next-auth/react';
import { useState, useEffect, useRef } from 'react';
import { viewModels } from '@maany_shr/e-class-models';
import { trpc } from '../trpc/cms-client';
import { useListNotificationsPresenter } from '../hooks/use-list-notifications-presenter';
import { useMarkNotificationsAsReadPresenter } from '../hooks/use-mark-notifications-as-read-presenter';
import {
  DefaultError,
  DefaultLoading,
  DefaultNotFound,
  NotificationGrid,
  ExtendedNotification,
} from '@maany_shr/e-class-ui-kit';
import { useRequiredPlatform } from '../context/platform-context';

interface ActivityHistoryProps {
  locale: TLocale;
}

export default function ActivityHistory({ locale }: ActivityHistoryProps) {
  const t = useTranslations('pages.activityHistory');
  const currentLocale = useLocale() as TLocale;
  const session = useSession();
  const { platform } = useRequiredPlatform();

  // Determine user type from session roles
  const getUserType = (): 'student' | 'coach' => {
    const roles = session.data?.user?.roles || [];
    return roles.includes('coach') ? 'coach' : 'student';
  };

  const userType = getUserType();

  // Add state for error message
  const [errorMessage, setErrorMessage] = useState<string | undefined>(undefined);

  // TRPC utils for cache invalidation
  const utils = trpc.useUtils();

  // State for notifications - poll every 30 seconds for new notifications
  const [notificationsResponse, { refetch: refetchNotifications }] = trpc.listNotifications.useSuspenseQuery({}, {
    refetchInterval: 30000, // Refetch every 30 seconds
  });

  const [listNotificationsViewModel, setListNotificationsViewModel] = useState<
    viewModels.TListNotificationsViewModel | undefined
  >(undefined);

  const { presenter: listNotificationsPresenter } = useListNotificationsPresenter(
    setListNotificationsViewModel,
  );

  // State for mark notifications as read
  const [markNotificationsViewModel, setMarkNotificationsViewModel] = useState<
    viewModels.TMarkNotificationsAsReadViewModel | undefined
  >(undefined);

  const { presenter: markNotificationsPresenter } = useMarkNotificationsAsReadPresenter(
    setMarkNotificationsViewModel,
  );

  const gridRef = useRef<any>(null);

  // Present the notifications data when response changes
  // Using useEffect with ONLY response dependency ensures presentation happens once per data fetch
  useEffect(() => {
    // @ts-ignore
    listNotificationsPresenter.present(notificationsResponse, listNotificationsViewModel);
  }, [notificationsResponse, listNotificationsPresenter]);

  // TRPC mutation for marking notifications as read with proper callbacks
  const markNotificationsAsReadMutation = trpc.markNotificationsAsRead.useMutation({
    onMutate: () => {
      setErrorMessage(undefined);
    },
    onSuccess: async (data) => {
      setErrorMessage(undefined);
      // @ts-ignore
      markNotificationsPresenter.present(data, markNotificationsViewModel);
      // Invalidate cache and refetch to get updated data from backend
      await utils.listNotifications.invalidate();
      await utils.countUnreadNotifications.invalidate();
    },

    onError: (error) => {
      setErrorMessage(error.message);
    }
  });

  // Mark a single notification as read (no navigation)
  const handleMarkAsRead = (notification: ExtendedNotification) => {
    if (!notification.isRead) {
      const numericId = Number(notification.id);
      if (!Number.isNaN(numericId)) {
        markNotificationsAsReadMutation.mutate({ notificationIds: [numericId] });
      }
    }
  };

  // Handle notification action click â€” open URL and mark as read
  const handleNotificationClick = (notification: ExtendedNotification) => {
    if (notification.action?.url && notification.action.url !== '#') {
      window.open(notification.action.url, '_blank', 'noopener,noreferrer');
    }
    handleMarkAsRead(notification);
  };

  // Handle mark selected notifications as read
  const handleMarkAllAsRead = (notificationIds: (number | string)[]) => {
    const numericIds = notificationIds.map(id => Number(id)).filter(id => !Number.isNaN(id));

    if (numericIds.length > 0) {
      markNotificationsAsReadMutation.mutate({
        notificationIds: numericIds
      });
    }
  };

  // Loading state - auth is handled in server component
  if (!listNotificationsViewModel) {
    return <DefaultLoading locale={locale} variant="minimal" />;
  }

  if (listNotificationsViewModel.mode === 'not-found') {
    return <DefaultNotFound locale={locale} />;
  }

  // Error handling - notifications failed to load
  if (listNotificationsViewModel.mode === 'kaboom') {
    return (
      <DefaultError
        type="simple"
        locale={locale}
        title={t('loadError.title')}
        description={t('loadError.description')}
        onRetry={() => refetchNotifications()}
      />
    );
  }

  // Extract notifications data and convert to ExtendedNotification format
  const notificationsData = listNotificationsViewModel.data;

  const extendedNotifications: ExtendedNotification[] = notificationsData.notifications
    .filter(notification => notification.actionTitle && notification.actionUrl)
    .map(notification => ({
      id: notification.id,
      message: notification.message,
      isRead: notification.isRead,
      platform: platform.name, // Use platform name from context
      timestamp: typeof notification.createdAt === 'string'
        ? notification.createdAt
        : new Date(notification.createdAt).toISOString(), // Backend sends string, handle as string primarily
      action: {
        title: notification.actionTitle,
        url: notification.actionUrl
      },
    }));

  return (
    <div className="flex flex-col h-[calc(100vh-200px)] space-y-5">
      <div className="flex-shrink-0">
        <h1>{t('title')}</h1>
        <p className="text-text-secondary">{t('description')}</p>
      </div>

      {/* Features from Notion:
        - FEAT-5 (listNotifications)
        - FEAT-95 (markNotificationsAsRead)
      */}
      <div className="flex-1 min-h-0">
        <NotificationGrid
          locale={locale}
          notifications={extendedNotifications}
          onNotificationClick={handleNotificationClick}
          onMarkAsRead={handleMarkAsRead}
          onMarkAllRead={handleMarkAllAsRead}
          gridRef={gridRef}
          variant={userType}
          loading={markNotificationsAsReadMutation.isPending}
        />
      </div>

      {errorMessage && (
        <DefaultError
          type="simple"
          locale={locale}
          title={t('error.title')}
          description={errorMessage}
        />
      )}
    </div>
  );
}
